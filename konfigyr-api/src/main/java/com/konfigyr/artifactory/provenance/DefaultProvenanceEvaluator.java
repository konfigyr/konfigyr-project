package com.konfigyr.artifactory.provenance;

import com.konfigyr.artifactory.PropertyMetadata;
import com.konfigyr.artifactory.VersionedArtifact;
import com.konfigyr.artifactory.digest.PropertyMetadataChecksumGenerator;
import com.konfigyr.io.ByteArray;
import com.konfigyr.version.Version;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jooq.DSLContext;
import org.jooq.SelectField;
import org.jooq.impl.DSL;
import org.springframework.lang.NonNull;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

import static com.konfigyr.data.tables.PropertyDefinitions.PROPERTY_DEFINITIONS;
import static com.konfigyr.data.tables.ArtifactVersionProperties.ARTIFACT_VERSION_PROPERTIES;

/**
 * The default implementation of the {@link ProvenanceEvaluator} that operates on a unique property identifier,
 * namely the checksum generated by the {@link com.konfigyr.artifactory.digest.PropertyMetadataChecksumGenerator}.
 * For each new piece of {@link PropertyMetadata} ingested, it follows these steps:
 * <ol>
 *     <li>
 *         It retrieves the existing {@link Provenance} record for the property using its checksum.
 *     </li>
 *     <li>
 *         If no record exists, it creates a new one, initializing the first and last seen versions with
 *         the current version and setting the occurrence count to 1.
 *     </li>
 *     <li>
 *         If a record already exists, it updates the fields as follows:
 *         <ul>
 *             <li>
 *                 {@code firstSeenVersion} It compares the version from the new metadata with the
 *                 current {@code firstSeenVersion}. If the new version is semantically earlier, it replaces
 *                 the current `{@code firstSeenVersion}.
 *             </li>
 *             <li>
 *                 {@code `lastSeenVersion`}: It compares the version from the new metadata with the
 *                 current {@code `lastSeenVersion`}. If the new version is semantically later, it replaces
 *                 the current {@code `lastSeenVersion`}.
 *             </li>
 *             <li>
 *                 {@code occurrences}: The evaluator increments the occurrence count, assuming the
 *                 newly ingested metadata corresponds to a unique version not yet recorded. A more
 *                 robust implementation could maintain a set of seen versions to ensure uniqueness.
 *             </li>
 *         </ul>
 *     </li>
 * </ol>
 *
 * @author Vladimir Spasic
 * @since 1.0.0
 */
@Slf4j
@RequiredArgsConstructor
public class DefaultProvenanceEvaluator implements ProvenanceEvaluator {

	private static final List<SelectField<?>> SELECTABLE_PROVENANCE_FIELDS = List.of(
			PROPERTY_DEFINITIONS.CHECKSUM,
			PROPERTY_DEFINITIONS.FIRST_SEEN,
			PROPERTY_DEFINITIONS.LAST_SEEN,
			PROPERTY_DEFINITIONS.OCCURRENCES,
			ARTIFACT_VERSION_PROPERTIES.ARTIFACT_VERSION_ID
	);

	private final PropertyMetadataChecksumGenerator generator = PropertyMetadataChecksumGenerator.getInstance();

	private final DSLContext context;

	@NonNull
	@Override
	@Transactional(readOnly = true, label = "provenance-evaluator.evaluate", isolation = Isolation.SERIALIZABLE)
	public EvaluationResult evaluate(@NonNull VersionedArtifact version, @NonNull PropertyMetadata metadata) {
		final ByteArray checksum = generator.generate(metadata);

		log.debug("Evaluating provenance for artifact version '{}' and property '[name={}, checksum={}]'",
				version.format(), metadata.name(), checksum.encode());

		final Optional<ProvenanceState> currentProvenance = retrieveCurrentProvenance(version, checksum);

		// it is a new property, generate the initial provenance for the current version...
		if (currentProvenance.isEmpty()) {
			final Provenance provenance = new Provenance(checksum, version.version(), version.version(), 1);

			log.debug("Provenance evaluation result for a new property with: [name={}, version={}, provenance={}]",
					metadata.name(), version.format(), provenance);

			return new EvaluationResult.New(version, metadata, provenance);
		}

		final ProvenanceState state = currentProvenance.get();

		if (state.linked()) {
			final Provenance provenance = new Provenance(checksum, state.firstSeen(), state.lastSeen(), state.occurrences());

			log.debug("Provenance evaluation result for an already used property with: [name={}, version={}, provenance={}]",
					metadata.name(), version.format(), provenance);

			return new EvaluationResult.Used(version, metadata, provenance);
		}

		Version firstSeen = state.firstSeen();
		Version lastSeen = state.lastSeen();

		if (firstSeen.compareTo(version.version()) > 0) {
			firstSeen = version.version();
		}

		if (lastSeen.compareTo(version.version()) < 0) {
			lastSeen = version.version();
		}

		final Provenance provenance = new Provenance(checksum, firstSeen, lastSeen, state.occurrences() + 1);

		log.debug("Provenance evaluation result for an unused property that with: [name={}, version={}, provenance={}]",
				metadata.name(), version.format(), provenance);

		return new EvaluationResult.Unused(version, metadata, provenance);
	}

	private Optional<ProvenanceState> retrieveCurrentProvenance(@NonNull VersionedArtifact version, @NonNull ByteArray checksum) {
		return context.select(SELECTABLE_PROVENANCE_FIELDS)
				.from(PROPERTY_DEFINITIONS)
				.leftJoin(ARTIFACT_VERSION_PROPERTIES)
				.on(DSL.and(
						ARTIFACT_VERSION_PROPERTIES.PROPERTY_DEFINITION_ID.eq(PROPERTY_DEFINITIONS.ID),
						ARTIFACT_VERSION_PROPERTIES.ARTIFACT_VERSION_ID.eq(version.id().get())
				))
				.where(DSL.and(
						PROPERTY_DEFINITIONS.ARTIFACT_ID.eq(version.artifact().get()),
						PROPERTY_DEFINITIONS.CHECKSUM.eq(checksum)
				))
				.fetchOptional(record -> new ProvenanceState(
						record.get(PROPERTY_DEFINITIONS.CHECKSUM),
						record.get(PROPERTY_DEFINITIONS.FIRST_SEEN, Version.class),
						record.get(PROPERTY_DEFINITIONS.LAST_SEEN, Version.class),
						record.get(PROPERTY_DEFINITIONS.OCCURRENCES),
						record.get(ARTIFACT_VERSION_PROPERTIES.ARTIFACT_VERSION_ID) != null
				));
	}

	private record ProvenanceState(
			@NonNull ByteArray checksum,
			@NonNull Version firstSeen,
			@NonNull Version lastSeen,
			int occurrences,
			boolean linked
	) {

	}
}
