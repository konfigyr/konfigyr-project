package com.konfigyr.identity.authorization.jwk;

import com.konfigyr.crypto.TokenGenerator;
import com.konfigyr.io.ByteArray;
import com.nimbusds.jose.Algorithm;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.JWEAlgorithm;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.*;
import com.nimbusds.jose.jwk.gen.ECKeyGenerator;
import com.nimbusds.jose.jwk.gen.JWKGenerator;
import com.nimbusds.jose.jwk.gen.RSAKeyGenerator;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.springframework.lang.NonNull;
import org.springframework.security.crypto.keygen.StringKeyGenerator;
import org.springframework.security.oauth2.jose.jws.JwsAlgorithm;
import org.springframework.util.Assert;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.security.Provider;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.time.*;
import java.util.Date;
import java.util.Set;
import java.util.function.Supplier;

/**
 * Enumeration of supported {@link JWK} algorithms that is used by the Konfigyr Identity server.
 * <p>
 * The algorithms define the following specifications:
 * <ul>
 *     <li>{@link KeyType Key type}</li>
 *     <li>{@link KeyUse Key usage}</li>
 *     <li>{@link Algorithm The actual JWK key algorithm}</li>
 *     <li>{@link KeyOperation Supported JWK key operations}</li>
 * </ul>
 *
 * @author Vladimir Spasic
 * @since 1.0.0
 */
public enum KeyAlgorithm implements JwsAlgorithm, Supplier<Algorithm> {

	/**
	 * {@link KeyType#RSA} encryption based algorithm.
	 *
	 * @see JWEAlgorithm#RSA_OAEP_256
	 */
	RSA_OAEP_256(KeyType.RSA, KeyUse.ENCRYPTION, JWEAlgorithm.RSA_OAEP_256, KeyOperation.ENCRYPT, KeyOperation.DECRYPT),

	/**
	 * {@link KeyType#EC} encryption based algorithm.
	 *
	 * @see JWEAlgorithm#ECDH_ES_A128KW
	 */
	ECDH_ES_A128KW(KeyType.EC, KeyUse.ENCRYPTION, JWEAlgorithm.ECDH_ES_A128KW, KeyOperation.ENCRYPT, KeyOperation.DECRYPT),

	/**
	 * {@link KeyType#RSA} signature based algorithm.
	 *
	 * @see JWSAlgorithm#RS256
	 */
	RS256(KeyType.RSA, KeyUse.SIGNATURE, JWSAlgorithm.RS256, KeyOperation.SIGN, KeyOperation.VERIFY),

	/**
	 * {@link KeyType#EC} signature based algorithm.
	 *
	 * @see JWSAlgorithm#ES256
	 */
	ES256(KeyType.EC, KeyUse.SIGNATURE, JWSAlgorithm.ES256, KeyOperation.SIGN, KeyOperation.VERIFY);

	static final Provider provider = new BouncyCastleProvider();
	static final StringKeyGenerator keyGenerator = TokenGenerator.getInstance(16);

	private final KeyType type;
	private final KeyUse usage;
	private final Algorithm algorithm;
	private final Set<KeyOperation> operations;

	KeyAlgorithm(KeyType type, KeyUse usage, Algorithm algorithm, KeyOperation... operations) {
		this.operations = Set.of(operations);
		this.algorithm = algorithm;
		this.usage = usage;
		this.type = type;
	}

	/**
	 * Returns the underlying algorithm used by {@link JWK keys} generated by this {@link KeyAlgorithm}.
	 *
	 * @return JWK algorithm, never {@literal null}
	 */
	@NonNull
	@Override
	public Algorithm get() {
		return algorithm;
	}

	/**
	 * Returns the name underlying algorithm used by {@link JWK keys} generated by this {@link KeyAlgorithm}.
	 *
	 * @return JWK algorithm name, never {@literal null}
	 */
	@NonNull
	@Override
	public String getName() {
		return algorithm.getName();
	}

	/**
	 * Returns the {@link KeyType} used by {@link JWK keys} generated by this {@link KeyAlgorithm}.
	 *
	 * @return JWK key type, never {@literal null}
	 */
	@NonNull
	public KeyType type() {
		return type;
	}

	/**
	 * Returns the {@link KeyUse usage type} for {@link JWK keys} generated by this {@link KeyAlgorithm}.
	 *
	 * @return JWK key use, never {@literal null}
	 */
	@NonNull
	public KeyUse usage() {
		return usage;
	}

	/**
	 * Returns the supported {@link KeyOperation key operations} for {@link JWK keys} generated
	 * by this {@link KeyAlgorithm}.
	 *
	 * @return JWK key operations, never {@literal null}
	 */
	@NonNull
	public Set<KeyOperation> operations() {
		return operations;
	}

	/**
	 * Creates a new {@link AsymmetricJWK} that matches the current {@link KeyAlgorithm}.
	 *
	 * @param expiry JWK expiration period, can't be {@literal null}
	 * @param <T> Asymmetric JWK generic type
	 * @return the generated JWK, never {@literal null}
	 * @see JWKGenerator
	 */
	@NonNull
	<T extends JWK & AsymmetricJWK> T generate(@NonNull Period expiry) throws JOSEException {
		Assert.isTrue(!expiry.isZero(), "JWK expiration period must be positive");
		Assert.isTrue(!expiry.isNegative(), "JWK expiration period must be positive");

		final JWKGenerator<T> generator = generatorFor(this);
		final OffsetDateTime timestamp = OffsetDateTime.now(ZoneOffset.UTC);

		return generator
				.keyID(keyGenerator.generateKey())
				.provider(provider)
				.keyOperations(operations)
				.algorithm(algorithm)
				.keyUse(usage)
				.issueTime(Date.from(timestamp.toInstant()))
				.notBeforeTime(Date.from(timestamp.toInstant()))
				.expirationTime(Date.from(timestamp.plus(expiry).toInstant()))
				.generate();
	}

	@NonNull
	KeyPair createKeyPair(@NonNull ByteArray publicKey, @NonNull ByteArray privateKey) throws JOSEException {
		try {
			final KeyFactory factory = keyFactoryFor(this);

			return new KeyPair(
					factory.generatePublic(new X509EncodedKeySpec(publicKey.array())),
					factory.generatePrivate(new PKCS8EncodedKeySpec(privateKey.array()))
			);
		} catch (NoSuchAlgorithmException ex) {
			throw new JOSEException("Unsupported key factory algorithm Key Algorithm: " + this, ex);
		} catch (InvalidKeySpecException ex) {
			throw new JOSEException("Unsupported key specification for Key Algorithm: " + this, ex);
		}
	}

	/**
	 * Attempt to resolve the provided {@link Algorithm JWK Algorithm} to a {@link KeyAlgorithm}.
	 *
	 * @param algorithm the JWK algorithm, can't be null
	 * @return the resolved {@link KeyAlgorithm}
	 * @throws IllegalArgumentException when no matching algorithm exists
	 */
	public static KeyAlgorithm from(@NonNull Algorithm algorithm) {
		for (KeyAlgorithm candidate : KeyAlgorithm.values()) {
			if (candidate.algorithm.equals(algorithm) || candidate.getName().equals(algorithm.getName())) {
				return candidate;
			}
		}
		throw new IllegalArgumentException("Unsupported key algorithm: " + algorithm.getName());
	}

	@SuppressWarnings("unchecked")
	private static <T extends JWK & AsymmetricJWK> JWKGenerator<T> generatorFor(@NonNull KeyAlgorithm algorithm) {
		return (JWKGenerator<T>) switch (algorithm) {
			case RS256, RSA_OAEP_256 -> new RSAKeyGenerator(2048);
			case ES256, ECDH_ES_A128KW -> new ECKeyGenerator(Curve.P_256);
		};
	}

	private static KeyFactory keyFactoryFor(@NonNull KeyAlgorithm algorithm) throws NoSuchAlgorithmException {
		return switch (algorithm) {
			case RS256, RSA_OAEP_256 -> KeyFactory.getInstance("RSA", provider);
			case ES256, ECDH_ES_A128KW -> KeyFactory.getInstance("ECDSA", provider);
		};
	}

}
